PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX coin: <http://purl.org/court/def/2009/coin#>


SELECT ?this ?thisType

    ?root ?separator ?fragmentSeparator

    ?baseResource ?baseRel ?baseRev
    ?containmentSegment ?fragmentPrefix
    ?component ?object

    ?segment0
    ?component1 ?segment1 ?object1 ?tokenValue1
    ?component2 ?segment2 ?object2 ?tokenValue2
    ?component3 ?segment3 ?object3 ?tokenValue3
    ?component4 ?segment4 ?object4

WHERE {

    ?scheme a coin:CoinScheme;
        coin:root ?root .
    OPTIONAL { ?scheme coin:separator ?separator . }
    OPTIONAL { ?scheme coin:fragmentSeparator ?fragmentSeparator . }


    # Via related base resource containment (base URI assumed to have been
    # previously coined).
    {
        ?relContainment a coin:Containment;
            coin:scheme ?scheme;
            coin:component ?component .
        {
            ?relContainment coin:baseRel ?baseRel .
            ?this ?baseRel ?baseResource .
        } UNION {
            ?relContainment coin:baseRev ?baseRev .
            ?baseResource ?baseRev ?this .
        }
        ?this ?component ?object .
        OPTIONAL { ?relContainment coin:segment ?containmentSegment . }
        OPTIONAL { ?relContainment coin:fragmentPrefix ?fragmentPrefix . }


    # Via a base contains pattern.
    # .. using copy-paste+increment (sparql cannot recurse)
    } UNION {

        ?base a coin:Base; coin:scheme ?scheme .
        OPTIONAL { ?base coin:segment ?segment0 . }

        ?base coin:contains ?contains1 .
        # [1]{
        OPTIONAL {
            ?contains1 coin:component ?component1 .
            OPTIONAL {
                ?this ?component1 ?object1 .
                OPTIONAL {
                    ?contains1 coin:useTokenSet ?tokenSet1 .
                    ?token1 a coin:Token; coin:tokenSet ?tokenSet1;
                        coin:represents ?object1; rdf:value ?tokenValue1 .
                }
                FILTER(isLITERAL(?object1) || BOUND(?tokenValue1))
            }
        }
        OPTIONAL { ?contains1 coin:segment ?segment1 . }
        FILTER(BOUND(?object1) || (!BOUND(?component1) && BOUND(?segment1)))
        OPTIONAL {
            ?contains1 coin:forType ?forType1 .
            ?this rdf:type ?thisType .
        } FILTER((!BOUND(?forType1) || ?forType1 = ?thisType))
        #next
        OPTIONAL {
            ?contains1 coin:contains ?contains2 .
            OPTIONAL {
                #[2]{
                OPTIONAL {
                    ?contains2 coin:component ?component2 .
                    OPTIONAL {
                        ?this ?component2 ?object2 .
                        OPTIONAL {
                            ?contains2 coin:useTokenSet ?tokenSet2 .
                            ?token2 a coin:Token; coin:tokenSet ?tokenSet2;
                                coin:represents ?object2; rdf:value ?tokenValue2 .
                        }
                        FILTER(isLITERAL(?object2) || BOUND(?tokenValue2))
                    }
                }
                OPTIONAL { ?contains2 coin:segment ?segment2 . }
                FILTER(BOUND(?object2) || (!BOUND(?component2) && BOUND(?segment2)))
                OPTIONAL {
                    ?contains2 coin:forType ?forType2 .
                    ?this rdf:type ?thisType .
                } FILTER((!BOUND(?forType2) || ?forType2 = ?thisType))
                #next
                OPTIONAL {
                    ?contains2 coin:contains ?contains3 .
                    OPTIONAL {
                        #[3]{
                        OPTIONAL {
                            ?contains3 coin:component ?component3 .
                            OPTIONAL {
                                ?this ?component3 ?object3 .
                                OPTIONAL {
                                    ?contains3 coin:useTokenSet ?tokenSet3 .
                                    ?token3 a coin:Token; coin:tokenSet ?tokenSet3;
                                        coin:represents ?object3; rdf:value ?tokenValue3 .
                                }
                                FILTER(isLITERAL(?object3) || BOUND(?tokenValue3))
                            }
                        }
                        OPTIONAL { ?contains3 coin:segment ?segment3 . }
                        FILTER(BOUND(?object3) || (!BOUND(?component3) && BOUND(?segment3)))
                        OPTIONAL {
                            ?contains3 coin:forType ?forType3 .
                            ?this rdf:type ?thisType .
                        } FILTER((!BOUND(?forType3) || ?forType3 = ?thisType))
                        #next
                        OPTIONAL {
                            ?contains3 coin:contains ?contains4 .
                            #[leaf]{
                            OPTIONAL {
                                ?contains4 coin:component ?component4 .
                                ?this ?component4 ?object4 FILTER(isLITERAL(?object4)) .
                                OPTIONAL { ?contains4 coin:segment ?segment4 . }
                            }
                            #}[leaf]
                        }
                        #}[3]
                    }
                }
                #}[2]
            }
        }
        #}[1]
        # .. remove these to get partial results
        FILTER(!BOUND(?contains4) || BOUND(?object4))#|| BOUND(?segment4))
        FILTER(!BOUND(?contains3) || BOUND(?object3) || BOUND(?segment3))
        FILTER(!BOUND(?contains2) || BOUND(?object2) || BOUND(?segment2))
    }

}
